import socket
import time
from contextlib import closing


class BasicClient:
    """BasicClient class to handle socket connections."""

    def __init__(self, host, port):
        """
        Construct client for specified port and host. Note, this creates
        the client object but the connection is not made until the
        'connect()' method is called.
        :param host: the host name
        :param port: the port number
        """
        self.port = port
        self.host = host
        self.socket = None
        self.input = None
        self.output = None
        self.debug = None
        self.last_connect_attempt = 0

    def __del__(self):
        """Finalizer makes sure socket and stream resources are freed."""
        self.disconnect()

    def set_debug_stream(self, debug):
        """
        Call this function to specify a print stream for debug messages.
        Debug messages will be generated by BasicClient and the derived
        classes for various network actions.
        If you don't call this function, no debug messages are generated.
        :param debug: debug stream
        """
        self.debug = debug

    def connect(self):
        """
        Connect to the previously specified host and port.
        :raises IOError: if can't open socket.
        :raises socket.gaierror: if host cannot be resolved.
        """
        if self.is_connected():
            self.disconnect()

        self.last_connect_attempt = time.time()
        if self.debug:
            self.debug.write(f"Connecting to host {self.host if self.host else '(unknown)'}, port {self.port}\n")
        self.socket = self.do_connect(self.host, self.port)
        self.input = self.socket.makefile('rb')
        self.output = self.socket.makefile('wb')

    @staticmethod
    def do_connect(host, port):
        """
        When several client objects are created in different threads, the
        connect call can get an interrupted system call (inside the native
        implementation) and subsequently generate a SocketException. The
        use of this method prevents this by synchronizing at the class
        level. Only one socket connection can be made at a time.
        :param host: the host name
        :param port: the port number
        :return: the new Socket
        :raises IOError: if can't open socket.
        :raises socket.gaierror: if host cannot be resolved.
        """
        with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
            s.settimeout(20)
            s.connect((host, port))
            return s

    def disconnect(self):
        """
        Disconnect from the server. Close input & output streams and release
        all socket resources.
        This function should be called when any of the other methods throws
        an exception. You can then call connect() again to reconnect to the
        server.
        """
        try:
            if self.input:
                self.input.close()
        except Exception as e:
            print(f"Error closing input: {e}")

        try:
            if self.output:
                self.output.close()
        except Exception as e:
            print(f"Error closing output: {e}")

        try:
            if self.socket:
                self.socket.close()
        except Exception as e:
            print(f"Error closing socket: {e}")

        if self.debug:
            self.debug.write(f"Disconnected from host {self.host if self.host else '(unknown)'}, port {self.port}\n")

        self.input = None
        self.output = None
        self.socket = None

    def send_data(self, data):
        """
        Sends a byte array of data to the socket and flushes it.
        :param data: the byte array.
        :raises IOError: on IO error
        """
        if self.output is None:
            raise IOError("BasicClient socket closed.")
        self.output.write(data)
        self.output.flush()

    def get_name(self):
        """
        :return: String in the form host:port
        """
        return f"{self.host}:{self.port}"

    def is_connected(self):
        """
        :return: true if currently connected
        """
        return self.socket is not None

    def get_port(self):
        """
        :return: port number
        """
        return self.port

    def set_port(self, port):
        """
        Set the port number.
        If currently connected this does nothing until you disconnect and reconnect.
        :param port: the number
        """
        self.port = port

    def get_host(self):
        """
        :return: the host name
        """
        return self.host

    def set_host(self, host):
        """
        Sets the host name.
        If currently connected this does nothing until you disconnect and reconnect.
        :param host: the host name
        """
        self.host = host

    def get_socket(self):
        """
        :return: Socket for this connection, or None if not connected.
        """
        return self.socket

    def get_input_stream(self):
        """
        :return: InputStream for this connection, or None if not connected.
        """
        return self.input

    def get_output_stream(self):
        """
        :return: OutputStream for this connection, or None if not connected.
        """
        return self.output

    def get_last_connect_attempt(self):
        """
        :return: time when last connect attempt was made.
        """
        return self.last_connect_attempt
